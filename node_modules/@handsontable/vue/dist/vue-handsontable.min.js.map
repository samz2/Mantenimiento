{"version":3,"file":"vue-handsontable.min.js","sources":["../../src/common/helpers.ts"],"sourcesContent":["import Handsontable from 'hot-alias';\nimport {HotTableProps, VueProps} from './types';\n\n/**\n * Rewrite the settings object passed to the watchers to be a clean array/object prepared to use within Handsontable config.\n *\n * @param {*} observerSettings Watcher object containing the changed data.\n * @returns {Object|Array}\n */\nexport function rewriteSettings(observerSettings): any[] | object {\n  const settingsType = Object.prototype.toString.call(observerSettings);\n  let settings: any[] | object | null = null;\n  let type: { array?: boolean, object?: boolean } = {};\n\n  if (settingsType === '[object Array]') {\n    settings = [];\n    type.array = true;\n\n  } else if (settingsType === '[object Object]') {\n    settings = {};\n    type.object = true;\n  }\n\n  if (type.array || type.object) {\n    for (const p in observerSettings) {\n      if (observerSettings.hasOwnProperty(p)) {\n        settings[p] = observerSettings[p];\n      }\n    }\n\n  } else {\n    settings = observerSettings;\n  }\n\n  return settings;\n}\n\n/**\n * Initialize Handsontable.\n */\nexport function hotInit(): void {\n  const unmappedSettings: any[] = [\n    this.settings ? this.settings : this._props,\n  ];\n\n  if (this.settings) {\n    unmappedSettings.push(this._props)\n  }\n\n  this.hotInstance = new Handsontable(this.$el, prepareSettings(unmappedSettings[0], unmappedSettings[1]));\n\n  preventInternalEditWatch(this);\n}\n\n/**\n * Private method to ensure the table is not calling `updateSettings` after editing cells.\n * @private\n */\nfunction preventInternalEditWatch(component) {\n  component.hotInstance.addHook('beforeChange', () => {\n    component.__internalEdit = true;\n  });\n\n  component.hotInstance.addHook('beforeCreateRow', () => {\n    component.__internalEdit = true;\n  });\n\n  component.hotInstance.addHook('beforeCreateCol', () => {\n    component.__internalEdit = true;\n  });\n\n  component.hotInstance.addHook('beforeRemoveRow', () => {\n    component.__internalEdit = true;\n  });\n\n  component.hotInstance.addHook('beforeRemoveCol', () => {\n    component.__internalEdit = true;\n  });\n}\n\n/**\n * Generate an object containing all the available Handsontable properties and plugin hooks.\n *\n * @returns {Object}\n */\nexport function propFactory(): VueProps<HotTableProps> {\n  const registeredHooks: string[] = Handsontable.hooks.getRegistered();\n\n  //TODO: workaround for `DefaultSettings` being an interface and not a class in `handsontable.ts`\n  const hotTemp: any = Handsontable;\n  const propSchema: VueProps<HotTableProps> = new hotTemp.DefaultSettings();\n\n  for (let prop in propSchema) {\n    propSchema[prop] = {};\n  }\n\n  for (let i = 0; i < registeredHooks.length; i++) {\n    propSchema[registeredHooks[i]] = {\n      type: Function\n    };\n  }\n\n  propSchema.id = {\n    type: String,\n    default: 'hot-' + Math.random().toString(36).substring(5)\n  };\n\n  propSchema.settings = {\n    type: Object as () => Handsontable.DefaultSettings\n  };\n\n  return propSchema;\n}\n\n/**\n * Generate and object containing all the available Handsontable properties and hooks tied to the Handsontable updating function.\n *\n * @param {Function} updateFunction Function used to update a single changed property.\n * @returns {Object}\n */\nexport function propWatchFactory(updateFunction: Function) {\n  const props: object = propFactory();\n  const watchList = {};\n\n  for (const prop in props) {\n    if (props.hasOwnProperty(prop)) {\n      if (prop !== 'settings') {\n        watchList[prop] = {\n          handler: function (...args) {\n            return updateFunction.call(this, prop, ...args);\n          },\n          deep: true\n        };\n\n        watchList[`settings.${prop}`] = {\n          handler: function (...args) {\n            return updateFunction.call(this, prop, ...args);\n          },\n          deep: true\n        };\n      }\n    }\n  }\n\n  return watchList;\n}\n\n// The `this` value in the functions below points to the Vue component instance. They're not meant to used anywhere but in the context of the component.\n\n/**\n * Update the Handsontable instance with a single changed property.\n *\n * @param {String} updatedProperty Updated property name.\n * @param {Object} updatedValue Watcher-generated updated value object.\n * @param {Object} oldValue Watcher-generated old value object.\n */\nexport function updateHotSettings(updatedProperty: string, updatedValue: object, oldValue: object) {\n  const newSettings = {};\n\n  if (updatedProperty === 'data' && this.__internalEdit === true) {\n    this.__internalEdit = false;\n    return;\n  }\n\n  newSettings[updatedProperty] = rewriteSettings(updatedValue);\n  this.hotInstance.updateSettings(newSettings);\n}\n\n/**\n * Prepare the settings object containing the `on`-properties to be used in the Handsontable configuration.\n *\n * @param {Object} settings An object containing the properties, including the `on`-prefixed hook names.\n * @param {Object} [additionalSettings] An additional object containing the properties, including the `on`-prefixed hook names.\n * @returns {Object} An object containing the properties, with the `on`-prefixes trimmed.\n */\nexport function prepareSettings(settings: object, additionalSettings?: object): Handsontable.DefaultSettings {\n  const newSettings = {};\n\n  for (const key in settings) {\n    if (settings.hasOwnProperty(key) && settings[key] !== void 0) {\n      newSettings[key] = settings[key];\n    }\n  }\n\n  for (const key in additionalSettings) {\n    if (additionalSettings.hasOwnProperty(key) && additionalSettings[key] !== void 0) {\n      newSettings[key] = additionalSettings[key];\n    }\n  }\n\n  return newSettings;\n}\n"],"names":["rewriteSettings","observerSettings","settingsType","Object","prototype","toString","call","settings","type","array","object","p","hasOwnProperty","hotInit","component","unmappedSettings","this","_props","push","hotInstance","Handsontable","$el","prepareSettings","addHook","__internalEdit","propFactory","registeredHooks","hooks","getRegistered","propSchema","DefaultSettings","prop","i","length","Function","id","String","Math","random","substring","propWatchFactory","updateFunction","props","watchList","args","updateHotSettings","updatedProperty","updatedValue","oldValue","newSettings","updateSettings","additionalSettings","key"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;wSASgBA,EAAgBC,OACxBC,EAAeC,OAAOC,UAAUC,SAASC,KAAKL,GAChDM,EAAkC,KAClCC,EAA8C,MAE7B,mBAAjBN,KACS,KACNO,OAAQ,GAEa,oBAAjBP,MACE,KACNQ,QAAS,GAGZF,EAAKC,OAASD,EAAKE,WAChB,IAAMC,KAAKV,EACVA,EAAiBW,eAAeD,OACzBA,GAAKV,EAAiBU,WAKxBV,SAGNM,EAMT,SAAgBM,QAkBkBC,EAjB1BC,EAA0B,CAC9BC,KAAKT,SAAWS,KAAKT,SAAWS,KAAKC,QAGnCD,KAAKT,YACUW,KAAKF,KAAKC,aAGxBE,YAAc,IAAIC,EAAaJ,KAAKK,IAAKC,EAAgBP,EAAiB,GAAIA,EAAiB,MASpED,EAPPE,MAQfG,YAAYI,QAAQ,eAAgB,aAClCC,gBAAiB,MAGnBL,YAAYI,QAAQ,kBAAmB,aACrCC,gBAAiB,MAGnBL,YAAYI,QAAQ,kBAAmB,aACrCC,gBAAiB,MAGnBL,YAAYI,QAAQ,kBAAmB,aACrCC,gBAAiB,MAGnBL,YAAYI,QAAQ,kBAAmB,aACrCC,gBAAiB,IAS/B,SAAgBC,QACRC,EAA4BN,EAAaO,MAAMC,gBAI/CC,EAAsC,IADvBT,EACmCU,oBAEnD,IAAIC,KAAQF,IACJE,GAAQ,OAGhB,IAAIC,EAAI,EAAGA,EAAIN,EAAgBO,OAAQD,MAC/BN,EAAgBM,IAAM,MACzBE,mBAICC,GAAK,MACRC,eACG,OAASC,KAAKC,SAASjC,SAAS,IAAIkC,UAAU,MAG9ChC,SAAW,MACdJ,QAGD0B,WASOW,EAAiBC,OACzBC,EAAgBjB,IAChBkB,EAAY,cAEPZ,GACLW,EAAM9B,eAAemB,IACV,aAATA,MACQA,GAAQ,SACP,sCAAaa,gDACbH,EAAenC,cAAKU,KAAMe,UAASa,WAEtC,iBAGcb,GAAU,SACrB,sCAAaa,gDACbH,EAAenC,cAAKU,KAAMe,UAASa,WAEtC,SAdT,IAAMb,KAAQW,IAARX,UAoBJY,EAYT,SAAgBE,EAAkBC,EAAyBC,EAAsBC,OACzEC,EAAc,GAEI,SAApBH,IAAsD,IAAxB9B,KAAKQ,kBAK3BsB,GAAmB9C,EAAgB+C,QAC1C5B,YAAY+B,eAAeD,SALzBzB,gBAAiB,WAeVF,EAAgBf,EAAkB4C,OAC1CF,EAAc,OAEf,IAAMG,KAAO7C,EACZA,EAASK,eAAewC,SAA0B,IAAlB7C,EAAS6C,OAC/BA,GAAO7C,EAAS6C,QAI3B,IAAMA,KAAOD,EACZA,EAAmBvC,eAAewC,SAAoC,IAA5BD,EAAmBC,OACnDA,GAAOD,EAAmBC,WAInCH"}