'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var Handsontable = _interopDefault(require('handsontable'));

/**
 * Rewrite the settings object passed to the watchers to be a clean array/object prepared to use within Handsontable config.
 *
 * @param {*} observerSettings Watcher object containing the changed data.
 * @returns {Object|Array}
 */
function rewriteSettings(observerSettings) {
    var settingsType = Object.prototype.toString.call(observerSettings);
    var settings = null;
    var type = {};
    if (settingsType === '[object Array]') {
        settings = [];
        type.array = true;
    } else if (settingsType === '[object Object]') {
        settings = {};
        type.object = true;
    }
    if (type.array || type.object) {
        for (var p in observerSettings) {
            if (observerSettings.hasOwnProperty(p)) {
                settings[p] = observerSettings[p];
            }
        }
    } else {
        settings = observerSettings;
    }
    return settings;
}
/**
 * Initialize Handsontable.
 */
function hotInit() {
    var unmappedSettings = [this.settings ? this.settings : this._props];
    if (this.settings) {
        unmappedSettings.push(this._props);
    }
    this.hotInstance = new Handsontable(this.$el, prepareSettings(unmappedSettings[0], unmappedSettings[1]));
    preventInternalEditWatch(this);
}
/**
 * Private method to ensure the table is not calling `updateSettings` after editing cells.
 * @private
 */
function preventInternalEditWatch(component) {
    component.hotInstance.addHook('beforeChange', function () {
        component.__internalEdit = true;
    });
    component.hotInstance.addHook('beforeCreateRow', function () {
        component.__internalEdit = true;
    });
    component.hotInstance.addHook('beforeCreateCol', function () {
        component.__internalEdit = true;
    });
    component.hotInstance.addHook('beforeRemoveRow', function () {
        component.__internalEdit = true;
    });
    component.hotInstance.addHook('beforeRemoveCol', function () {
        component.__internalEdit = true;
    });
}
/**
 * Generate an object containing all the available Handsontable properties and plugin hooks.
 *
 * @returns {Object}
 */
function propFactory() {
    var registeredHooks = Handsontable.hooks.getRegistered();
    //TODO: workaround for `DefaultSettings` being an interface and not a class in `handsontable.ts`
    var hotTemp = Handsontable;
    var propSchema = new hotTemp.DefaultSettings();
    for (var prop in propSchema) {
        propSchema[prop] = {};
    }
    for (var i = 0; i < registeredHooks.length; i++) {
        propSchema[registeredHooks[i]] = {
            type: Function
        };
    }
    propSchema.id = {
        type: String,
        default: 'hot-' + Math.random().toString(36).substring(5)
    };
    propSchema.settings = {
        type: Object
    };
    return propSchema;
}
/**
 * Generate and object containing all the available Handsontable properties and hooks tied to the Handsontable updating function.
 *
 * @param {Function} updateFunction Function used to update a single changed property.
 * @returns {Object}
 */
function propWatchFactory(updateFunction) {
    var props = propFactory();
    var watchList = {};

    var _loop = function _loop(prop) {
        if (props.hasOwnProperty(prop)) {
            if (prop !== 'settings') {
                watchList[prop] = {
                    handler: function handler() {
                        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
                            args[_key] = arguments[_key];
                        }

                        return updateFunction.call.apply(updateFunction, [this, prop].concat(args));
                    },
                    deep: true
                };
                watchList['settings.' + prop] = {
                    handler: function handler() {
                        for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
                            args[_key2] = arguments[_key2];
                        }

                        return updateFunction.call.apply(updateFunction, [this, prop].concat(args));
                    },
                    deep: true
                };
            }
        }
    };

    for (var prop in props) {
        _loop(prop);
    }
    return watchList;
}
// The `this` value in the functions below points to the Vue component instance. They're not meant to used anywhere but in the context of the component.
/**
 * Update the Handsontable instance with a single changed property.
 *
 * @param {String} updatedProperty Updated property name.
 * @param {Object} updatedValue Watcher-generated updated value object.
 * @param {Object} oldValue Watcher-generated old value object.
 */
function updateHotSettings(updatedProperty, updatedValue, oldValue) {
    var newSettings = {};
    if (updatedProperty === 'data' && this.__internalEdit === true) {
        this.__internalEdit = false;
        return;
    }
    newSettings[updatedProperty] = rewriteSettings(updatedValue);
    this.hotInstance.updateSettings(newSettings);
}
/**
 * Prepare the settings object containing the `on`-properties to be used in the Handsontable configuration.
 *
 * @param {Object} settings An object containing the properties, including the `on`-prefixed hook names.
 * @param {Object} [additionalSettings] An additional object containing the properties, including the `on`-prefixed hook names.
 * @returns {Object} An object containing the properties, with the `on`-prefixes trimmed.
 */
function prepareSettings(settings, additionalSettings) {
    var newSettings = {};
    for (var key in settings) {
        if (settings.hasOwnProperty(key) && settings[key] !== void 0) {
            newSettings[key] = settings[key];
        }
    }
    for (var _key3 in additionalSettings) {
        if (additionalSettings.hasOwnProperty(_key3) && additionalSettings[_key3] !== void 0) {
            newSettings[_key3] = additionalSettings[_key3];
        }
    }
    return newSettings;
}

var version = "3.1.0";

var HotTable = {
    name: 'HotTable',
    props: propFactory(),
    watch: propWatchFactory(updateHotSettings),
    data: function data() {
        return {
            __internalEdit: false,
            hotInstance: null
        };
    },
    methods: {
        hotInit: hotInit
    },
    mounted: function mounted() {
        return this.hotInit();
    },
    beforeDestroy: function beforeDestroy() {
        this.hotInstance.destroy();
    },
    version: version
};

/* script */
var __vue_script__ = HotTable;

/* template */
var __vue_render__ = function __vue_render__() {
  var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('div', { attrs: { "id": _vm.id } });
};
var __vue_staticRenderFns__ = [];

/* style */
var __vue_inject_styles__ = undefined;
/* scoped */
var __vue_scope_id__ = undefined;
/* module identifier */
var __vue_module_identifier__ = undefined;
/* functional template */
var __vue_is_functional_template__ = false;
/* component normalizer */
function __vue_normalize__(template, style, script, scope, functional, moduleIdentifier, createInjector, createInjectorSSR) {
  var component = (typeof script === 'function' ? script.options : script) || {};

  // For security concerns, we use only base name in production mode.
  component.__file = "HotTable.vue";

  if (!component.render) {
    component.render = template.render;
    component.staticRenderFns = template.staticRenderFns;
    component._compiled = true;

    if (functional) component.functional = true;
  }

  component._scopeId = scope;

  return component;
}
/* style inject */

/* style inject SSR */

var HotTable$1 = __vue_normalize__({ render: __vue_render__, staticRenderFns: __vue_staticRenderFns__ }, __vue_inject_styles__, __vue_script__, __vue_scope_id__, __vue_is_functional_template__, __vue_module_identifier__, undefined, undefined);

exports.default = HotTable$1;
exports.HotTable = HotTable;
exports.rewriteSettings = rewriteSettings;
exports.hotInit = hotInit;
exports.propFactory = propFactory;
exports.propWatchFactory = propWatchFactory;
exports.updateHotSettings = updateHotSettings;
exports.prepareSettings = prepareSettings;
