import Handsontable from 'handsontable';

/**
 * Rewrite the settings object passed to the watchers to be a clean array/object prepared to use within Handsontable config.
 *
 * @param {*} observerSettings Watcher object containing the changed data.
 * @returns {Object|Array}
 */
function rewriteSettings(observerSettings) {
    const settingsType = Object.prototype.toString.call(observerSettings);
    let settings = null;
    let type = {};
    if (settingsType === '[object Array]') {
        settings = [];
        type.array = true;
    }
    else if (settingsType === '[object Object]') {
        settings = {};
        type.object = true;
    }
    if (type.array || type.object) {
        for (const p in observerSettings) {
            if (observerSettings.hasOwnProperty(p)) {
                settings[p] = observerSettings[p];
            }
        }
    }
    else {
        settings = observerSettings;
    }
    return settings;
}
/**
 * Initialize Handsontable.
 */
function hotInit() {
    const unmappedSettings = [
        this.settings ? this.settings : this._props,
    ];
    if (this.settings) {
        unmappedSettings.push(this._props);
    }
    this.hotInstance = new Handsontable(this.$el, prepareSettings(unmappedSettings[0], unmappedSettings[1]));
    preventInternalEditWatch(this);
}
/**
 * Private method to ensure the table is not calling `updateSettings` after editing cells.
 * @private
 */
function preventInternalEditWatch(component) {
    component.hotInstance.addHook('beforeChange', () => {
        component.__internalEdit = true;
    });
    component.hotInstance.addHook('beforeCreateRow', () => {
        component.__internalEdit = true;
    });
    component.hotInstance.addHook('beforeCreateCol', () => {
        component.__internalEdit = true;
    });
    component.hotInstance.addHook('beforeRemoveRow', () => {
        component.__internalEdit = true;
    });
    component.hotInstance.addHook('beforeRemoveCol', () => {
        component.__internalEdit = true;
    });
}
/**
 * Generate an object containing all the available Handsontable properties and plugin hooks.
 *
 * @returns {Object}
 */
function propFactory() {
    const registeredHooks = Handsontable.hooks.getRegistered();
    //TODO: workaround for `DefaultSettings` being an interface and not a class in `handsontable.ts`
    const hotTemp = Handsontable;
    const propSchema = new hotTemp.DefaultSettings();
    for (let prop in propSchema) {
        propSchema[prop] = {};
    }
    for (let i = 0; i < registeredHooks.length; i++) {
        propSchema[registeredHooks[i]] = {
            type: Function
        };
    }
    propSchema.id = {
        type: String,
        default: 'hot-' + Math.random().toString(36).substring(5)
    };
    propSchema.settings = {
        type: Object
    };
    return propSchema;
}
/**
 * Generate and object containing all the available Handsontable properties and hooks tied to the Handsontable updating function.
 *
 * @param {Function} updateFunction Function used to update a single changed property.
 * @returns {Object}
 */
function propWatchFactory(updateFunction) {
    const props = propFactory();
    const watchList = {};
    for (const prop in props) {
        if (props.hasOwnProperty(prop)) {
            if (prop !== 'settings') {
                watchList[prop] = {
                    handler: function (...args) {
                        return updateFunction.call(this, prop, ...args);
                    },
                    deep: true
                };
                watchList[`settings.${prop}`] = {
                    handler: function (...args) {
                        return updateFunction.call(this, prop, ...args);
                    },
                    deep: true
                };
            }
        }
    }
    return watchList;
}
// The `this` value in the functions below points to the Vue component instance. They're not meant to used anywhere but in the context of the component.
/**
 * Update the Handsontable instance with a single changed property.
 *
 * @param {String} updatedProperty Updated property name.
 * @param {Object} updatedValue Watcher-generated updated value object.
 * @param {Object} oldValue Watcher-generated old value object.
 */
function updateHotSettings(updatedProperty, updatedValue, oldValue) {
    const newSettings = {};
    if (updatedProperty === 'data' && this.__internalEdit === true) {
        this.__internalEdit = false;
        return;
    }
    newSettings[updatedProperty] = rewriteSettings(updatedValue);
    this.hotInstance.updateSettings(newSettings);
}
/**
 * Prepare the settings object containing the `on`-properties to be used in the Handsontable configuration.
 *
 * @param {Object} settings An object containing the properties, including the `on`-prefixed hook names.
 * @param {Object} [additionalSettings] An additional object containing the properties, including the `on`-prefixed hook names.
 * @returns {Object} An object containing the properties, with the `on`-prefixes trimmed.
 */
function prepareSettings(settings, additionalSettings) {
    const newSettings = {};
    for (const key in settings) {
        if (settings.hasOwnProperty(key) && settings[key] !== void 0) {
            newSettings[key] = settings[key];
        }
    }
    for (const key in additionalSettings) {
        if (additionalSettings.hasOwnProperty(key) && additionalSettings[key] !== void 0) {
            newSettings[key] = additionalSettings[key];
        }
    }
    return newSettings;
}

var version="3.1.0";

const HotTable = {
    name: 'HotTable',
    props: propFactory(),
    watch: propWatchFactory(updateHotSettings),
    data: function () {
        return {
            __internalEdit: false,
            hotInstance: null
        };
    },
    methods: {
        hotInit: hotInit
    },
    mounted: function () {
        return this.hotInit();
    },
    beforeDestroy: function () {
        this.hotInstance.destroy();
    },
    version: version
};

/* script */
            const __vue_script__ = HotTable;
            
/* template */
var __vue_render__ = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{attrs:{"id":_vm.id}})};
var __vue_staticRenderFns__ = [];

  /* style */
  const __vue_inject_styles__ = undefined;
  /* scoped */
  const __vue_scope_id__ = undefined;
  /* module identifier */
  const __vue_module_identifier__ = undefined;
  /* functional template */
  const __vue_is_functional_template__ = false;
  /* component normalizer */
  function __vue_normalize__(
    template, style, script,
    scope, functional, moduleIdentifier,
    createInjector, createInjectorSSR
  ) {
    const component = (typeof script === 'function' ? script.options : script) || {};

    // For security concerns, we use only base name in production mode.
    component.__file = "HotTable.vue";

    if (!component.render) {
      component.render = template.render;
      component.staticRenderFns = template.staticRenderFns;
      component._compiled = true;

      if (functional) component.functional = true;
    }

    component._scopeId = scope;

    return component
  }
  /* style inject */
  
  /* style inject SSR */
  

  
  var HotTable$1 = __vue_normalize__(
    { render: __vue_render__, staticRenderFns: __vue_staticRenderFns__ },
    __vue_inject_styles__,
    __vue_script__,
    __vue_scope_id__,
    __vue_is_functional_template__,
    __vue_module_identifier__,
    undefined,
    undefined
  );

export default HotTable$1;
export { HotTable, rewriteSettings, hotInit, propFactory, propWatchFactory, updateHotSettings, prepareSettings };
